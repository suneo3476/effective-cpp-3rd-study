# Item 8: デストラクタから例外を漏らすな

## 問題：デストラクタから例外が投げられると

```cpp
class Widget {
public:
    ~Widget() {
        throw std::runtime_error("destructor error");  // 例外を投げる
    }
};

void doSomething() {
    std::vector<Widget> v(10);  // 10個のWidgetを作成
}  // ここでvが破棄される
```

`doSomething()`が終わるとき、vectorは10個のWidgetすべてのデストラクタを呼ぼうとします。

```
~Widget() ← 1個目で例外A が投げられる
~Widget() ← 2個目
~Widget() ← 3個目
...
~Widget() ← 10個目
```

1個目で例外が投げられても、vectorは残り9個も破棄しないといけません（リソースリークを防ぐため）。

もし2個目のデストラクタでも例外が投げられたら...

**2つの例外が同時にアクティブ → 未定義動作！**

### Q: 「同時にアクティブ」とは？

**例外がアクティブ = 投げられてからcatchされるまでの状態**

通常の例外処理：
```cpp
try {
    throw std::runtime_error("error!");  // 例外がアクティブになる
    // ↓ ここからcatchまでの間、例外はアクティブ
} catch (...) {  // ここで例外が処理される（アクティブ終了）
    // 処理
}
```

vectorの破棄で起きること：
```
1個目のデストラクタ実行
  ↓
例外A が投げられる ← 例外A がアクティブになる
  ↓
でもvectorは残り9個も破棄しないといけない
  ↓
2個目のデストラクタ実行（例外Aはまだアクティブのまま！）
  ↓
例外B が投げられる ← 例外B もアクティブになる
  ↓
例外A と 例外B が両方アクティブ！← 未定義動作
```

C++では、同時にアクティブな例外は1つまで。2つ以上は未定義動作。

## 実際の例：データベース接続

```cpp
class DBConnection {
public:
    static DBConnection create();  // 接続を作る
    void close();  // 接続を閉じる（失敗すると例外を投げる）
};
```

クライアントが`close()`を呼び忘れないように、RAIIパターンでラッパーを作る：

```cpp
class DBConn {
public:
    ~DBConn() {
        db.close();  // デストラクタで自動的にclose
    }
private:
    DBConnection db;
};
```

使い方：
```cpp
{
    DBConn dbc(DBConnection::create());
    // ... データベースを使う ...
}  // スコープを抜けると自動的にcloseされる
```

### Q: db.close()が例外を投げたら？

こういうケースで問題になります：

```cpp
void doSomething() {
    DBConn dbc(DBConnection::create());

    // 何か処理...
    throw std::runtime_error("処理中にエラー！");  // ← 例外A

}  // スコープを抜ける = dbcのデストラクタが呼ばれる
```

流れ：
1. `throw std::runtime_error(...)` が投げられる ← **例外A がアクティブ**
2. 例外Aが投げられたので、**スタック巻き戻し**が始まる
3. スタック巻き戻しで、`dbc`のデストラクタが呼ばれる
4. デストラクタの中で`db.close()`が実行される
5. `db.close()`が失敗して例外を投げる ← **例外B もアクティブに**
6. 例外A と 例外B が同時にアクティブ！← **未定義動作**

## スタック巻き戻し（Stack Unwinding）

**スタック巻き戻し = 例外が投げられたときの特殊な制御フロー**

```cpp
void funcC() {
    DBConn dbc(DBConnection::create());  // ローカル変数
    throw std::runtime_error("エラー!");  // 例外を投げる
}

void funcB() {
    int x = 10;  // ローカル変数
    funcC();     // funcCを呼ぶ
}

void funcA() {
    try {
        funcB();  // funcBを呼ぶ
    } catch (...) {
        // ここで例外を処理
    }
}
```

実行の流れ：
```
funcA呼び出し
  ↓
funcB呼び出し（スタックに積まれる）
  ↓
funcC呼び出し（スタックに積まれる）
  ↓
例外が投げられる！
  ↓
catchブロックを探す... funcCにはない
  ↓
funcCを抜ける ← このとき dbc のデストラクタが呼ばれる！
  ↓
catchブロックを探す... funcBにもない
  ↓
funcBを抜ける ← このとき x が破棄される
  ↓
funcAのcatchブロックを発見！
  ↓
例外処理
```

例外が投げられると、**catchが見つかるまで関数を遡っていき、その途中でローカル変数のデストラクタを呼ぶ**。これがスタック巻き戻し。

だから、デストラクタは**例外がアクティブな状態で呼ばれる可能性がある**。

## 解決策

### 1. プログラムを終了させる（abort）

```cpp
DBConn::~DBConn() {
    try {
        db.close();
    } catch (...) {
        // ログに記録
        std::abort();  // プログラム終了
    }
}
```

**問題点**：
- 保存していないデータが失われる
- 他の重要な処理ができない
- ユーザーに適切なエラーメッセージを見せられない

### 2. 例外を飲み込む

```cpp
DBConn::~DBConn() {
    try {
        db.close();
    } catch (...) {
        // ログに記録して、例外を飲み込む（何もしない）
    }
}
```

**問題点**：
- **重要な情報が失われる** - 何か失敗したという情報が消える
- クライアントコードは問題に気づけない
- データベース接続が閉じられなかったことに、プログラムは気づけない

書籍：「一般的に、例外を飲み込むのは悪い考え」

### 3. ベストプラクティス：クライアントに処理する機会を与える

```cpp
class DBConn {
public:
    void close() {  // 通常の関数として close を提供
        db.close();
        closed = true;
    }

    ~DBConn() {
        if (!closed) {
            try {
                db.close();  // バックアップとして呼ぶ
            } catch (...) {
                // ログ記録して、飲み込むか終了
            }
        }
    }
private:
    DBConnection db;
    bool closed = false;
};
```

使い方：

```cpp
// パターン1: 例外を処理したい場合
{
    DBConn dbc(DBConnection::create());
    try {
        // ... 使う ...
        dbc.close();  // 自分で呼ぶ
    } catch (std::exception& e) {
        // closeが失敗した！ 適切に対処できる
        std::cerr << "接続を閉じられませんでした: " << e.what() << std::endl;
        // 代替処理、リトライ、ユーザーへの通知など
    }
}

// パターン2: 例外処理が不要な場合
{
    DBConn dbc(DBConnection::create());
    // ... 使う ...
}  // close()を呼ばない = デストラクタに任せる
   // でも、例外が投げられても文句は言えない
```

## なぜ通常の関数なら良いのか

**デストラクタ**：
```cpp
{
    DBConn dbc(...);
}  // ← ここで自動的に呼ばれる。try-catchで囲めない
```

**通常の関数**：
```cpp
try {
    dbc.close();  // ← 明示的に呼ぶ。try-catchで囲める
} catch (...) {
    // 例外を処理できる
}
```

**例外を投げる可能性がある操作は、デストラクタではなく、通常の関数として提供すべき。**

クライアントがその関数を呼べば、try-catchで例外を処理できる。

## 覚えておくこと

> デストラクタから例外を投げるな。デストラクタ内で呼ぶ関数が例外を投げる可能性がある場合、デストラクタはその例外をcatchして、飲み込むか、プログラムを終了させるべき。

> クラスのクライアントが、ある操作によって投げられる例外に反応する必要がある場合、その操作を行う通常の関数（非デストラクタ）を提供すべき。

## Q&A サマリ

1. **デストラクタから例外を投げると何が問題？** → 2つの例外が同時にアクティブになり、未定義動作になる。

2. **「同時にアクティブ」とは？** → 1つ目の例外がcatchされる前に、2つ目の例外が投げられること。

3. **スタック巻き戻しとは？** → 例外が投げられたとき、catchを探して関数を遡る制御フロー。その途中でデストラクタが呼ばれる。

4. **abort()の問題点は？** → プログラムが即座に終了し、保存していないデータが失われたり、適切なエラー処理ができない。

5. **例外を飲み込むのは何が悪い？** → 重要な情報（何か失敗した）が失われ、クライアントは問題に気づけない。

6. **ベストプラクティスは？** → 例外を投げる可能性がある操作を通常の関数として提供し、デストラクタはバックアップとして呼ぶ。

7. **なぜ通常の関数なら良い？** → 明示的に呼べるので、try-catchで囲んで例外を処理できる。デストラクタは自動的に呼ばれるので囲めない。

8. **クライアントがclose()を呼び忘れたら？** → デストラクタがバックアップとして呼ぶが、その時点で例外が投げられても処理できない。それはクライアントの選択。

## 参考文献

- Scott Meyers『Effective C++ 第3版』項目8
